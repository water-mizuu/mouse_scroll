{
    "sourceFile": "lib/mouse_scroll.dart",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 6,
            "patches": [
                {
                    "date": 1698513206164,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1699060476562,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,8 +5,9 @@\n import \"package:flutter/gestures.dart\";\r\n import \"package:flutter/material.dart\";\r\n import \"package:provider/provider.dart\";\r\n \r\n+\r\n class MouseScroll extends StatefulWidget {\r\n   const MouseScroll({\r\n     required this.builder,\r\n     this.controller,\r\n"
                },
                {
                    "date": 1699060509309,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,10 +5,10 @@\n import \"package:flutter/gestures.dart\";\r\n import \"package:flutter/material.dart\";\r\n import \"package:provider/provider.dart\";\r\n \r\n-\r\n-class MouseScroll extends StatefulWidget {\r\n+@optionalTypeArgs\r\n+class MouseScroll<Controller extends ScrollController> extends StatefulWidget {\r\n   const MouseScroll({\r\n     required this.builder,\r\n     this.controller,\r\n     super.key,\r\n@@ -16,14 +16,14 @@\n     this.duration = const Duration(milliseconds: 380),\r\n     this.scrollSpeed = 1.0,\r\n     this.animationCurve = Curves.easeOutQuart,\r\n   });\r\n-  final ScrollController? controller;\r\n+  final Controller? controller;\r\n   final ScrollPhysics mobilePhysics;\r\n   final Duration duration;\r\n   final double scrollSpeed;\r\n   final Curve animationCurve;\r\n-  final Widget Function(BuildContext, ScrollController, ScrollPhysics) builder;\r\n+  final Widget Function(BuildContext, Controller, ScrollPhysics) builder;\r\n \r\n   @override\r\n   State<MouseScroll> createState() => _MouseScrollState();\r\n }\r\n@@ -73,9 +73,9 @@\n \r\n const BouncingScrollPhysics kMobilePhysics = BouncingScrollPhysics();\r\n const NeverScrollableScrollPhysics kDesktopPhysics = NeverScrollableScrollPhysics();\r\n \r\n-class ScrollState with ChangeNotifier {\r\n+class ScrollState< with ChangeNotifier {\r\n   ScrollState(this.mobilePhysics, this.controller, this.duration);\r\n \r\n   final ScrollPhysics mobilePhysics;\r\n   final ScrollController controller;\r\n"
                },
                {
                    "date": 1699060542444,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,12 +24,12 @@\n   final Curve animationCurve;\r\n   final Widget Function(BuildContext, Controller, ScrollPhysics) builder;\r\n \r\n   @override\r\n-  State<MouseScroll> createState() => _MouseScrollState();\r\n+  State<MouseScroll<> createState() => _MouseScrollState();\r\n }\r\n \r\n-class _MouseScrollState extends State<MouseScroll> {\r\n+class _MouseScrollState<Controller extends ScrollController> extends State<MouseScroll<Controller>> {\r\n   late final ScrollController scrollController;\r\n \r\n   @override\r\n   void initState() {\r\n@@ -52,9 +52,9 @@\n     return ChangeNotifierProvider<ScrollState>(\r\n       create: (BuildContext context) => ScrollState(widget.mobilePhysics, scrollController, widget.duration),\r\n       builder: (BuildContext context, _) {\r\n         ScrollState scrollState = context.read<ScrollState>();\r\n-        ScrollController controller = scrollState.controller;\r\n+        Controller controller = scrollState.controller;\r\n         var (ScrollPhysics physics, _) = context.select((ScrollState s) => (s.activePhysics, s.updateState));\r\n \r\n         scrollState.handlePipelinedScroll?.call();\r\n         return Listener(\r\n@@ -73,9 +73,9 @@\n \r\n const BouncingScrollPhysics kMobilePhysics = BouncingScrollPhysics();\r\n const NeverScrollableScrollPhysics kDesktopPhysics = NeverScrollableScrollPhysics();\r\n \r\n-class ScrollState< with ChangeNotifier {\r\n+class ScrollState with ChangeNotifier {\r\n   ScrollState(this.mobilePhysics, this.controller, this.duration);\r\n \r\n   final ScrollPhysics mobilePhysics;\r\n   final ScrollController controller;\r\n"
                },
                {
                    "date": 1699060573828,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -24,9 +24,9 @@\n   final Curve animationCurve;\r\n   final Widget Function(BuildContext, Controller, ScrollPhysics) builder;\r\n \r\n   @override\r\n-  State<MouseScroll<> createState() => _MouseScrollState();\r\n+  State<MouseScroll<Controller>> createState() => _MouseScrollState<Controller>();\r\n }\r\n \r\n class _MouseScrollState<Controller extends ScrollController> extends State<MouseScroll<Controller>> {\r\n   late final ScrollController scrollController;\r\n@@ -73,13 +73,13 @@\n \r\n const BouncingScrollPhysics kMobilePhysics = BouncingScrollPhysics();\r\n const NeverScrollableScrollPhysics kDesktopPhysics = NeverScrollableScrollPhysics();\r\n \r\n-class ScrollState with ChangeNotifier {\r\n+class ScrollState<Controller extends ScrollController> with ChangeNotifier {\r\n   ScrollState(this.mobilePhysics, this.controller, this.duration);\r\n \r\n   final ScrollPhysics mobilePhysics;\r\n-  final ScrollController controller;\r\n+  final Controller controller;\r\n   final Duration duration;\r\n \r\n   late ScrollPhysics activePhysics = mobilePhysics;\r\n   double _futurePosition = 0;\r\n@@ -93,9 +93,9 @@\n   /// Scroll that is pipelined to be handled after the current render is finished.\r\n   /// This is used to ensure that the scroll is handled while transitioning from physics.\r\n   void Function()? handlePipelinedScroll;\r\n \r\n-  static double calcMaxDelta(ScrollController controller, double delta) {\r\n+  static double calcMaxDelta(ontroller controller, double delta) {\r\n     double pixels = controller.position.pixels;\r\n \r\n     return delta.sign > 0\r\n         ? math.min(pixels + delta, controller.position.maxScrollExtent) - pixels\r\n"
                },
                {
                    "date": 1699060617323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,12 +48,16 @@\n   }\r\n \r\n   @override\r\n   Widget build(BuildContext context) {\r\n-    return ChangeNotifierProvider<ScrollState>(\r\n-      create: (BuildContext context) => ScrollState(widget.mobilePhysics, scrollController, widget.duration),\r\n+    return ChangeNotifierProvider<ScrollState<Controller>>(\r\n+      create: (BuildContext context) => ScrollState<Controller>(\r\n+        widget.mobilePhysics,\r\n+        scrollController as Controller,\r\n+        widget.duration,\r\n+      ),\r\n       builder: (BuildContext context, _) {\r\n-        ScrollState scrollState = context.read<ScrollState>();\r\n+        ScrollState scrollState = context.read<ScrollState<>();\r\n         Controller controller = scrollState.controller;\r\n         var (ScrollPhysics physics, _) = context.select((ScrollState s) => (s.activePhysics, s.updateState));\r\n \r\n         scrollState.handlePipelinedScroll?.call();\r\n@@ -93,9 +97,9 @@\n   /// Scroll that is pipelined to be handled after the current render is finished.\r\n   /// This is used to ensure that the scroll is handled while transitioning from physics.\r\n   void Function()? handlePipelinedScroll;\r\n \r\n-  static double calcMaxDelta(ontroller controller, double delta) {\r\n+  static double calcMaxDelta(ScrollController controller, double delta) {\r\n     double pixels = controller.position.pixels;\r\n \r\n     return delta.sign > 0\r\n         ? math.min(pixels + delta, controller.position.maxScrollExtent) - pixels\r\n"
                },
                {
                    "date": 1699060648150,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n         scrollController as Controller,\r\n         widget.duration,\r\n       ),\r\n       builder: (BuildContext context, _) {\r\n-        ScrollState scrollState = context.read<ScrollState<>();\r\n+        ScrollState<Controller> scrollState = context.read();\r\n         Controller controller = scrollState.controller;\r\n         var (ScrollPhysics physics, _) = context.select((ScrollState s) => (s.activePhysics, s.updateState));\r\n \r\n         scrollState.handlePipelinedScroll?.call();\r\n"
                }
            ],
            "date": 1698513206164,
            "name": "Commit-0",
            "content": "// ignore_for_file: avoid_types_on_closure_parameters, omit_local_variable_types, discarded_futures\r\n\r\nimport \"dart:math\" as math;\r\n\r\nimport \"package:flutter/gestures.dart\";\r\nimport \"package:flutter/material.dart\";\r\nimport \"package:provider/provider.dart\";\r\n\r\nclass MouseScroll extends StatefulWidget {\r\n  const MouseScroll({\r\n    required this.builder,\r\n    this.controller,\r\n    super.key,\r\n    this.mobilePhysics = kMobilePhysics,\r\n    this.duration = const Duration(milliseconds: 380),\r\n    this.scrollSpeed = 1.0,\r\n    this.animationCurve = Curves.easeOutQuart,\r\n  });\r\n  final ScrollController? controller;\r\n  final ScrollPhysics mobilePhysics;\r\n  final Duration duration;\r\n  final double scrollSpeed;\r\n  final Curve animationCurve;\r\n  final Widget Function(BuildContext, ScrollController, ScrollPhysics) builder;\r\n\r\n  @override\r\n  State<MouseScroll> createState() => _MouseScrollState();\r\n}\r\n\r\nclass _MouseScrollState extends State<MouseScroll> {\r\n  late final ScrollController scrollController;\r\n\r\n  @override\r\n  void initState() {\r\n    super.initState();\r\n\r\n    scrollController = widget.controller ?? ScrollController();\r\n  }\r\n\r\n  @override\r\n  void dispose() {\r\n    if (widget.controller case null) {\r\n      scrollController.dispose();\r\n    }\r\n\r\n    super.dispose();\r\n  }\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return ChangeNotifierProvider<ScrollState>(\r\n      create: (BuildContext context) => ScrollState(widget.mobilePhysics, scrollController, widget.duration),\r\n      builder: (BuildContext context, _) {\r\n        ScrollState scrollState = context.read<ScrollState>();\r\n        ScrollController controller = scrollState.controller;\r\n        var (ScrollPhysics physics, _) = context.select((ScrollState s) => (s.activePhysics, s.updateState));\r\n\r\n        scrollState.handlePipelinedScroll?.call();\r\n        return Listener(\r\n          onPointerSignal: (PointerSignalEvent signalEvent) {\r\n            scrollState.handleDesktopScroll(signalEvent, widget.scrollSpeed, widget.animationCurve);\r\n          },\r\n          onPointerDown: (PointerDownEvent pointerEvent) {\r\n            scrollState.handleTouchScroll(pointerEvent);\r\n          },\r\n          child: widget.builder(context, controller, physics),\r\n        );\r\n      },\r\n    );\r\n  }\r\n}\r\n\r\nconst BouncingScrollPhysics kMobilePhysics = BouncingScrollPhysics();\r\nconst NeverScrollableScrollPhysics kDesktopPhysics = NeverScrollableScrollPhysics();\r\n\r\nclass ScrollState with ChangeNotifier {\r\n  ScrollState(this.mobilePhysics, this.controller, this.duration);\r\n\r\n  final ScrollPhysics mobilePhysics;\r\n  final ScrollController controller;\r\n  final Duration duration;\r\n\r\n  late ScrollPhysics activePhysics = mobilePhysics;\r\n  double _futurePosition = 0;\r\n  bool updateState = false;\r\n\r\n  bool _previousDeltaIsPositive = false;\r\n  double? _lastLock;\r\n\r\n  Future<void>? _animationEnd;\r\n\r\n  /// Scroll that is pipelined to be handled after the current render is finished.\r\n  /// This is used to ensure that the scroll is handled while transitioning from physics.\r\n  void Function()? handlePipelinedScroll;\r\n\r\n  static double calcMaxDelta(ScrollController controller, double delta) {\r\n    double pixels = controller.position.pixels;\r\n\r\n    return delta.sign > 0\r\n        ? math.min(pixels + delta, controller.position.maxScrollExtent) - pixels\r\n        : math.max(pixels + delta, controller.position.minScrollExtent) - pixels;\r\n  }\r\n\r\n  void handleDesktopScroll(\r\n    PointerSignalEvent event,\r\n    double scrollSpeed,\r\n    Curve animationCurve, {\r\n    bool shouldReadLastDirection = true,\r\n  }) {\r\n    // Ensure desktop physics is being used.\r\n    if (activePhysics == kMobilePhysics || _lastLock != null) {\r\n      if (_lastLock != null) {\r\n        updateState = !updateState;\r\n      }\r\n      if (event case PointerScrollEvent()) {\r\n        double pixels = controller.position.pixels;\r\n\r\n        /// If the scroll is at the top or bottom, don't allow the user to scroll further.\r\n        if (pixels <= controller.position.minScrollExtent && event.scrollDelta.dy < 0 ||\r\n            pixels >= controller.position.maxScrollExtent && event.scrollDelta.dy > 0) {\r\n          return;\r\n        } else {\r\n          activePhysics = kDesktopPhysics;\r\n        }\r\n\r\n        double computedDelta = calcMaxDelta(controller, event.scrollDelta.dy);\r\n        bool isOutOfBounds = pixels < controller.position.minScrollExtent || //\r\n            pixels > controller.position.maxScrollExtent;\r\n\r\n        if (!isOutOfBounds) {\r\n          controller.jumpTo(_lastLock ?? (pixels - computedDelta));\r\n        }\r\n        double deltaDifference = computedDelta - event.scrollDelta.dy;\r\n        handlePipelinedScroll = () {\r\n          handlePipelinedScroll = null;\r\n          double currentPos = controller.position.pixels;\r\n          double currentDelta = event.scrollDelta.dy;\r\n          bool shouldLock = _lastLock != null\r\n              ? (_lastLock == currentPos)\r\n              : (pixels != currentPos + deltaDifference &&\r\n                  (currentPos != controller.position.maxScrollExtent || currentDelta < 0) &&\r\n                  (currentPos != controller.position.minScrollExtent || currentDelta > 0));\r\n\r\n          if (!isOutOfBounds && shouldLock) {\r\n            controller.jumpTo(pixels);\r\n            _lastLock = pixels;\r\n            controller.position.moveTo(pixels).whenComplete(() {\r\n              if (activePhysics == kDesktopPhysics) {\r\n                activePhysics = kMobilePhysics;\r\n                notifyListeners();\r\n              }\r\n            });\r\n            return;\r\n          } else {\r\n            if (_lastLock != null || isOutOfBounds) {\r\n              double jumpTarget = _lastLock != null //\r\n                  ? pixels\r\n                  : (currentPos - calcMaxDelta(controller, currentDelta));\r\n\r\n              controller.jumpTo(jumpTarget);\r\n            }\r\n            _lastLock = null;\r\n            handleDesktopScroll(event, scrollSpeed, animationCurve, shouldReadLastDirection: false);\r\n          }\r\n        };\r\n        notifyListeners();\r\n      }\r\n    } else if (event case PointerScrollEvent()) {\r\n      bool currentDeltaPositive = event.scrollDelta.dy > 0;\r\n      if (shouldReadLastDirection && currentDeltaPositive == _previousDeltaIsPositive) {\r\n        _futurePosition += event.scrollDelta.dy * scrollSpeed;\r\n      } else {\r\n        _futurePosition = controller.position.pixels + event.scrollDelta.dy * scrollSpeed;\r\n      }\r\n      _previousDeltaIsPositive = currentDeltaPositive;\r\n\r\n      Future<void> animationEnd = _animationEnd = controller.animateTo(\r\n        _futurePosition,\r\n        duration: duration,\r\n        curve: animationCurve,\r\n      );\r\n      animationEnd.whenComplete(() {\r\n        if (animationEnd == _animationEnd && activePhysics == kDesktopPhysics) {\r\n          activePhysics = mobilePhysics;\r\n          notifyListeners();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  void handleTouchScroll(PointerDownEvent event) {\r\n    if (activePhysics == kDesktopPhysics) {\r\n      activePhysics = mobilePhysics;\r\n      notifyListeners();\r\n    }\r\n  }\r\n}\r\n\r\n/// Combination of [SingleChildScrollView] and [MouseScroll].\r\n/// Note: Property [physics] is ignored.\r\nclass MouseSingleChildScrollView extends StatelessWidget {\r\n  const MouseSingleChildScrollView({\r\n    super.key,\r\n\r\n    /// SingleScrollView properties\r\n    this.scrollDirection = Axis.vertical,\r\n    this.reverse = false,\r\n    this.padding,\r\n    this.primary,\r\n    this.physics,\r\n    this.controller,\r\n    this.child,\r\n    this.dragStartBehavior = DragStartBehavior.start,\r\n    this.clipBehavior = Clip.hardEdge,\r\n    this.restorationId,\r\n    this.keyboardDismissBehavior = ScrollViewKeyboardDismissBehavior.manual,\r\n\r\n    /// MouseScroll properties\r\n    this.mobilePhysics = kMobilePhysics,\r\n    this.duration = const Duration(milliseconds: 380),\r\n    this.scrollSpeed = 1.0,\r\n    this.animationCurve = Curves.easeOutQuart,\r\n  });\r\n\r\n  /// {@macro flutter.widgets.scroll_view.scrollDirection}\r\n  final Axis scrollDirection;\r\n\r\n  /// Whether the scroll view scrolls in the reading direction.\r\n  ///\r\n  /// For example, if the reading direction is left-to-right and\r\n  /// [scrollDirection] is [Axis.horizontal], then the scroll view scrolls from\r\n  /// left to right when [reverse] is false and from right to left when\r\n  /// [reverse] is true.\r\n  ///\r\n  /// Similarly, if [scrollDirection] is [Axis.vertical], then the scroll view\r\n  /// scrolls from top to bottom when [reverse] is false and from bottom to top\r\n  /// when [reverse] is true.\r\n  ///\r\n  /// Defaults to false.\r\n  final bool reverse;\r\n\r\n  /// The amount of space by which to inset the child.\r\n  final EdgeInsetsGeometry? padding;\r\n\r\n  /// An object that can be used to control the position to which this scroll\r\n  /// view is scrolled.\r\n  ///\r\n  /// Must be null if [primary] is true.\r\n  ///\r\n  /// A [ScrollController] serves several purposes. It can be used to control\r\n  /// the initial scroll position (see [ScrollController.initialScrollOffset]).\r\n  /// It can be used to control whether the scroll view should automatically\r\n  /// save and restore its scroll position in the [PageStorage] (see\r\n  /// [ScrollController.keepScrollOffset]). It can be used to read the current\r\n  /// scroll position (see [ScrollController.offset]), or change it (see\r\n  /// [ScrollController.animateTo]).\r\n  final ScrollController? controller;\r\n\r\n  /// {@macro flutter.widgets.scroll_view.primary}\r\n  final bool? primary;\r\n\r\n  /// How the scroll view should respond to user input.\r\n  ///\r\n  /// For example, determines how the scroll view continues to animate after the\r\n  /// user stops dragging the scroll view.\r\n  ///\r\n  /// Defaults to matching platform conventions.\r\n  final ScrollPhysics? physics;\r\n\r\n  /// The widget that scrolls.\r\n  ///\r\n  /// {@macro flutter.widgets.ProxyWidget.child}\r\n  final Widget? child;\r\n\r\n  /// {@macro flutter.widgets.scrollable.dragStartBehavior}\r\n  final DragStartBehavior dragStartBehavior;\r\n\r\n  /// {@macro flutter.material.Material.clipBehavior}\r\n  ///\r\n  /// Defaults to [Clip.hardEdge].\r\n  final Clip clipBehavior;\r\n\r\n  /// {@macro flutter.widgets.scrollable.restorationId}\r\n  final String? restorationId;\r\n\r\n  /// {@macro flutter.widgets.scroll_view.keyboardDismissBehavior}\r\n  final ScrollViewKeyboardDismissBehavior keyboardDismissBehavior;\r\n\r\n  final ScrollPhysics mobilePhysics;\r\n  final Duration duration;\r\n  final double scrollSpeed;\r\n  final Curve animationCurve;\r\n\r\n  @override\r\n  Widget build(BuildContext context) {\r\n    return MouseScroll(\r\n      mobilePhysics: mobilePhysics,\r\n      duration: duration,\r\n      scrollSpeed: scrollSpeed,\r\n      animationCurve: animationCurve,\r\n      controller: controller,\r\n      builder: (BuildContext context, ScrollController controller, ScrollPhysics physics) {\r\n        return SingleChildScrollView(\r\n          scrollDirection: scrollDirection,\r\n          reverse: reverse,\r\n          padding: padding,\r\n          primary: primary,\r\n          physics: this.physics ?? physics,\r\n          controller: controller,\r\n          dragStartBehavior: dragStartBehavior,\r\n          clipBehavior: clipBehavior,\r\n          restorationId: restorationId,\r\n          keyboardDismissBehavior: keyboardDismissBehavior,\r\n          child: child,\r\n        );\r\n      },\r\n    );\r\n  }\r\n}\r\n"
        }
    ]
}